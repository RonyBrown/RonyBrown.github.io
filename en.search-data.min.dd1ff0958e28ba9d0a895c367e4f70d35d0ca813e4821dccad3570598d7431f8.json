[{"id":0,"href":"/posts/note/git/git-page-note/","title":"Git Page Note","section":"Posts","content":"\rHugo构建GitHub Pages\r#\rHugo + GitHub Pages 搭建个人博客\r#\r创建 Hugo 网站\r#\r通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了。\nhugo new site ronyz-site 注：后续命令未经说明，均在cmd中的ronyz-site根目录下运行\n创建完成后，根目录 ronyz-site 包含以下文件\n.\r├── archetypes: default.md是生成博文的模版\r├── assets # 存放被 Hugo Pipes 处理的文件\r├── content # 存放markdown文件作为博文内容\r├── data # 存放 Hugo 处理的数据\r├── layouts # 存放布局文件\r├── static # 存放静态文件 图片 CSS JS文件\r├── themes: 存放不同的主题\r└── config.toml: 博客配置文件支持 JSON YAML TOML 三种格式配置文件 配置主题\r#\r当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目仓库，一般都会有很详细的安装及配置说明。\n官方主题网站: https://themes.gohugo.io/\n主题推荐:\nPure: https://themes.gohugo.io/hugo-theme-pure/ 关联主题仓库\r#\r我们可以将主题仓库直接 git clone 下来进行使用，例如在根目录ronyz-site下运行以下代码，即可下载pure主题.\ngit clone https://github.com/xiaoheiAh/hugo-theme-pure themes/pure 这种方式有一些弊端，当之后自己对主题进行修改后，可能会与原主题产生一些冲突，不方便版本管理与后续更新。官方更推荐使用的是将原主题仓库 fork 到自己的账户，并使用git submodule方式进行仓库链接，这样后续可以对主题的修改进行单独维护。\ncd ronyz-site/ git init git submodule add https://github.com/pseudoyu/pure themes/pure 然后在根目录下的 config.toml文件中添加新的一行:\ntheme = \u0026#34;pure\u0026#34; 更新主题\r#\r如果是 clone 了其他人的博客项目进行修改，则需要用以下命令进行初始化：\ngit submodule update --init --recursive 如果需要同步主题仓库的最新修改，需要运行以下命令：\ngit submodule update --remote 新建博文\r#\r完成后，可以通过hugo new命令发布新文章。\nhugo new posts/test.md ---\rtitle: \u0026#34;Test\u0026#34;\rdate: 2022-10-21T19:00:43+08:00\rdraft: true\r--- 这个命令会在content目录下建立posts目录，并在posts下生成test.md文件，博文书写就在这个文件里使用Markdown语法完成。博文的front matter里draft选项默认为true，需要改为false才能发表博文，建议直接更改上面说的archetypes目录下的default文件，把draft: true改为draft: false，这样生成的博文就是默认可以发表的。\n生成网页\r#\r为了查看生成的博客的效果，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。在cmd中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。\nhugo server -D 但此时只能在本地访问，如果想发布到Github Pages， 还需要借助GithubPages工具。\n配置文件\r#\r打开配置config.toml可以看到很多的参数可以配置，这里只描述最基本的内容，不同的主题可能会支持不同的参数配置，具体请看对应主题的说明文档。baseURL是站点的域名。title是站点的名称。theme是站点的主题。还有关于评论和打赏的相关配置，这些配置都可以参考官网主题的说明。\n每次发布的时候，都需要先执行hugo，把新写的文档按照主题进行渲染，所有生成的文件默认都在当前pulic的子目录下，可以在config里面配置到其他目录。然后把所有新的文件提交到github。提交代码之后，要等一段时间才生效。\nGitHub Pages 发布博客\r#\r我们希望 Hugo 生成的静态网站能通过 GitHub Pages 服务进行托管，而无需自己维护服务，更稳定、安全，因此我们需要上传 Hugo 生成的静态网页文件至 GitHub Page 项目仓库。\nGithub Pages 到底是在做什么？\r#\rA：Github Pages 本质上是一个静态网站托管系统，你可以使用它为你的每一个仓库制作一个静态网页入口。\n它有两种存在方式：\n识别 master branch 根目录下的：README.md 或者 index.html 识别 master branch 的 /docs 目录下的：README.md 或者 index.html 也就是说：我们可以把我们的静态网页直接存在 master branch，并在 Github Repository 的 Setting 页中打开 Github Pages 选项，就可以通过一个域名访问到我们的想要的网站了。\n实战操作：部署 Hugo 作为一个 GitHub Pages\r#\r将 Hugo 部署为 Github Pages 项目，并使用简单的 shell 脚本自动化整个过程\n第一步： 创建一个 Github 仓库\n登录后，点击右上角，出现下拉菜单，点击 Your repositories 进入页面 点击 New 进入 Creat a new repository 页面 Repository name这里一定要填 [你的github账号].github.io，像我的账号是ronybrown，所以我就要輸入ronybrown.github.io，然后按[Create Repository]。 第二步：创建新文章\nhugo new posts/my-first-post.md 这里面值得注意的是，通过上述命令行创建的文章中，会自动生成一部分文本如下：\n---\rtitle: \u0026#34;My First Post\u0026#34;\rdate: 2019-03-26T08:47:11+01:00\rdraft: true\r--- 我们需要把 draft : true 修改成 draft : false 才可以上传这篇文章\n第三步：修改配置文件 config.toml\n站点目录config.toml中baseURL要换成自己建立的仓库，如baseURL = “https://jianzhnie.github.io/\u0026quot;\n第四步： 进入站点根目录下，执行：\nhugo 执行后，站点根目录下会生成一个public文件夹，该文件下的内容即Hugo生成的整个静态网站。每次更新内容后，将 pubilc 目录里所有文件 push到GitHub即可。\n第五步：上传代码至 master\n首次使用的时候要执行以下命令：\ncd public git init git remote add origin https://github.com/jianzhnie/jianzhnie.github.io.git # 将本地目录链接到远程服务器的代码仓库 git add . git commit -m \u0026#34;[介绍，随便写点什么，比如日期]\u0026#34; git push -u origin master 稍等几分钟即可通过我们的自定义域名来访问我们的博客站点了，和我们hugo server本地调试完全一致。\n以后每次站点目录下执行hugo命令后，再到public下执行推送命令：\ngit add -A git commit -m \u0026#34;[介绍，随便写点什么，比如日期]\u0026#34; git push -u origin master GitAction 自动发布\r#\r通过上述命令我们可以手动发布我们的静态文件，但还是有以下弊端：\n发布步骤还是比较繁琐，本地调试后还需要切换到public/目录进行上传 无法对博客.md源文件进行备份与版本管理 因此，我们需要简单顺滑的方式来进行博客发布，首先我们初始化博客源文件的仓库，如我的仓库为RonyBrown/RonyBrown.github.io。\n因为我们的博客基于GitHub与GitHub Pages，可以通过官方提供的 GitHub Action 进行 CI 自动发布，下面我会进行详细讲解。GitHub Action 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。\n配置在仓库目录.github/workflows下，以.yml为后缀。我的 GitHub Action 配置为RonyzBrown/RonyBrown.github.io deploy.yml，自动发布示例配置如下：\nname: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: pseudoyu/pseudoyu.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} on 表示 GitHub Action 触发条件，我设置了 push、workflow_dispatch 和 schedule 三个条件：\npush，当这个项目仓库发生推送动作后，执行 GitHub Action workflow_dispatch，可以在 GitHub 项目仓库的 Action 工具栏进行手动调用 schedule，定时执行 GitHub Action，如我的设置为北京时间每天早上执行，主要是使用一些自动化统计 CI 来自动更新我博客的关于页面，如本周编码时间，影音记录等，如果你不需要定时功能，可以删除这个条件 jobs 表示 GitHub Action 中的任务，我们设置了一个 build 任务，runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。我们的 build 任务包含了 Checkout、Setup Hugo、Build Web 和 Deploy Web 四个主要步骤，其中 run 是执行的命令，uses 是 GitHub Action 中的一个插件，我们使用了 peaceiris/actions-hugo@v2 和 peaceiris/actions-gh-pages@v3 这两个插件。其中 Checkout 步骤中 with 中配置 submodules 值为 true 可以同步博客源仓库的子模块，即我们的主题模块。\n首先需要将上述 deploy.yml 中的 EXTERNAL_REPOSITORY 改为自己的 GitHub Pages 仓库，如我的设置为 pseudoyu/pseudoyu.github.io。\n因为我们需要从博客仓库推送到外部 GitHub Pages 仓库，需要特定权限，要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。\n总结\r#\r以上整个环境部署好之后，接下来的常用命令就是以下几个：\n站点目录下，新建文章，执行： hugo new post/文章名.md 添加文章内容或修改，包括修改主题之类的，在本地进行调试 修改完成，确定要上传到GitHub上后，站点目录下执行： hugo 进行编译，没错误的话修改的内容就顺利同步到public下了，然后cd public下，执行提交命令：\ngit add -A git commit -m \u0026#34;20200204-1\u0026#34; git push -u origin master 选择和配置Hugo 主题\r#\r流行的 Hugo 主题\r#\r使用 Hugo 博客时，我们最希望的是找到适合自己的一款主题，下面将图文结合介绍一些流行的 Hugo 主题。此外，关于写作的方法和 Hugo 主题修改，可以查阅本文参考中的 Hugo 官方文档，这里不再赘述。\nHugo 流行主题之 1：MemE\nMemE 是一个强大且可高度定制的 GoHugo 博客主题，专为个人博客设计。MemE 主题专注于优雅、简约、现代，以及代码的正确性。Github 地址：https://github.com/reuixiy/hugo-theme-meme。\nHugo 流行主题之 2：Clarity\n基于 VMware 的开源 Clarity 设计系统，具有丰富的代码支持、暗/光模式、移动支持等特点，为 Hugo 设计了一个具有技术意识的主题。Github 地址：https://github.com/chipzoller/hugo-clarity\nHugo 流行主题之 3： LoveIt\nLoveIt 是一个简洁、优雅且高效的 Hugo 博客主题。Github 地址： https://github.com/dillonzq/LoveIt\n它的原型基于 LeaveIt 主题 和 KeepIt 主题。LoveIt 主题 https://circleci.com/gh/dillonzq/LoveIt/tree/master\nHugo 流行主题之 4： Hugo Book Theme\nHugo documentation theme as simple as plain book. Github 地址： https://github.com/alex-shpak/hugo-book\nHugo 流行主题之 5：Hugo Academic Theme\nHugo Academic Theme 创建一个学术网站. Easily create a beautiful academic résumé or educational website using Hugo, GitHub, and Netlify. github地址： https://github.com/wowchemy/starter-hugo-academic\nHugo 流行主题之 6 ： Hugo Learn Theme\nThis repository contains a theme for Hugo, based on great Grav Learn Theme.\nVisit the theme documentation to see what is going on. It is actually built with this theme.\nHugo 流行主题之 7: Doks\nModern Documentation Theme\nDoks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize.\n配置 Hugo 主题\r#\r最好的搜索方式是在 https://github.com/ 中，搜索关键词：hugo theme。或者使用搜索引擎，搜索：hugo theme site:github.com。\n然后进入到项目目录中，下载安装我们需要的主题：\ngit clone https://github.com/theme-demo.git themes/theme-demo cp -r themes/theme-demo/_source/* source 希望使用下载的主题，添加 themes/theme-demo/exampleSite/config.toml 中的配置，还需要在 config.toml 中配置主题：\ntheme = \u0026#34;theme-demo\u0026#34; 此外，在有些 theme-demo 文件夹中会有 demo 或 example 目录，文件结构与新建的 Hugo 项目的文件结构几乎是一样的，这样设置是为了用户的配置可以覆盖掉主题的配置。\n使用技巧\r#\r图片问题\r#\r图片不居中问题:\n首先需要确保设置中hugo.toml文件中的设置为：\n[markup.goldmark] [markup.goldmark.renderer] unsafe = true 通过HTML的方式设置图像居中\n\u0026lt;div style=\u0026#34;text-align: center\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;[图像描述]\u0026#34; src=\u0026#34;[path]\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; 如果需要设置缩放：\n\u0026lt;div style=\u0026#34;text-align: center\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;[图像描述]\u0026#34; src=\u0026#34;[path]\u0026#34;, style=\u0026#34;width: 50%;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; "},{"id":1,"href":"/posts/inst/ad9361/RZ_AD9361_No-Os_pl_rw/","title":"AD9361驱动：ZYNQ PL端纯逻辑控制信号收发，PS端初始化AD9361","section":"Posts","content":"\r驱动介绍\r#\rAD9361通常搭配ZYNQ系列芯片使用，本驱动也是针对ZYNQ芯片对AD9361系列（包含AD9363、AD9364，后文统称AD9361）初始化以及基带数据收发。对于目前网上AD9361的驱动的资料，主要有两种方案：\n方案1：通过PS端初始化并控制数据的收发； 方案2：通过纯PL逻辑初始化并控制数据的收发。 但是方案1的现有资料都是通过PS端通过C语言编程来实现基带信号的收发，而对于大部分基带算法对时间刻度要求严格，仅通过C语言实现基带的收发难以满足很多实际需求，方案2将初始化与基带信号数据收发都集中在纯逻辑端，这样极大的方便了基带信号的发射与接收，但是AD9361初始化流程复杂且繁琐，且需要进行一定的校验才能稳定工作，也会占用过多的逻辑资源，目前测试过多个纯PL控制AD9361，大部分工作稳定性较差，且需要修改配置参数时比较麻烦。\n针对现有驱动存在的问题，对ADI提供的驱动进行修改升级，通过PS端对AD9361进行初始化，PL端对ADC与DAC的IQ通路进行读写，经过多个版本迭代升级，本驱动能够稳定工作，测试多次烧录运行都能够正常工作，且在运行时也可以很简单的修改AD9361收发参数，满足大部分通信算法的设计要求，提高开发的效率，帮助开发者专注于基带算法的实现，而不是浪费过多时间在配置驱动上。\n本驱动仅添加最核心的AD9361的驱动代码，在不影响系统的稳定性与复杂度的情况下尽量保留了完整的数据接口与控制接口，在Block Design中添加核心的IP与配置代码，引出了关键的收发信号接口，在PS端完善了数据通路，使PL端能够单独的控制数据的收发。对于本驱动，完成移植过程非常简单，只需要修改DDR、引脚约束这几个参数就能完成完整功能的移植。\n驱动移植\r#\r对于ZYNQ7020/ZYNQ7010系列芯片，使用芯片的PS端实现对AD9361初始化，PL端实现基带算法。对于本驱动，只需要进行简单的修改，驱动移植的大致流程分为：\n修改Block Design的ZYNQ7 Processing System IP中的DDR与少量IO 修改连接AD9361的引脚约束 修改Vitis中的platform 首先进入到Vivavo工程，打开Block Design，点击ZYNQ7 Processing System，进入到ZYNQ核设置框图，进入DDR Configuration，根据自己的板子选择对应的DDR型号，如下图。\n驱动中需要使用到少部分IO，本设计仅保留AD9361正常工作时使用到的外设IO，本驱动需要使用到：\nSPI UART 进入到Peripheral I/O Pins，勾选SPI0，调整对应的引脚（点亮对应引脚的框框），勾选UART1，调整对应的引脚。其他参数不做调整，如工程需要使用到其他外设，勾选并调整对应的外设引脚即可。如下图。\n设置好后点击下图标记处Validate Design按钮，\n点击运行后出现无错误无警告的提示框如下图。\n在工程文件下，如下图，右键system后点击Generate Ouput Products，确认运行。\n运行完成后，然后修改AD9361的对应的引脚约束，特别注意需要修改的是引脚编号与对应的引脚电平，不要同一个Bank使用不同的电平标准。\n特别注意：在确认DDR、SPI0、UART1、引脚约束设置都无误的情况下，点击Generate Bitstream编译整个工程，如下图。\n编译后无报错的情况下，如下图，需要导出硬件描述语言到Vitis里面。\n点击Vivado菜单栏处的File-Export-Export Hardware，如下图。\n导出后，在Vivado工程目录下面会生成xxx.xsa文件，如下图。\n将其复制到上级目录Vitis里面，如下图。\n打开Vitis，Workspace选择上图Vitis工程路径，由于Vitis的Platform使用的是绝对路径，所以当工程路径发生变化时，经常出现Platform无效的报错，这个时候最简单的方法是把原来的Platform删掉，重新添加由上文生成的xxx.xsa创建的Platform即可。右键ad936x [Platform]，点击Delete，删除之后，点击Vitis菜单栏中的File-New-Platform Project，Platform project name填写：ad936x，点击next进入下一步，如下图。\n浏览选择Vitis工程目录下的xxx.xsa文件，完成Platform创建，\n点击...按钮，\n选中刚刚创建的Platform，点击ok，选择yes，\n这个时候刚刚的Platfom的红色叉叉也消失了。\n首先右键ad936x [Platform]，点击build，编译后无报错，右键ad936x_app，点击build。\n编译无报错如下图，\n至此，PS端烧录文件与PL端烧录文件都已生成，下载代码到芯片里面就可以实现对AD9361的操作，但是由于工程目录可能发生变化，所以需要修改PL比特文件路径，点击绿色的Run按钮右边的倒三角，点击Run Configurations，按照下图的顺序进入到Bitstream路径选择，Bitstream为PL端的烧录比特文件，路径位于Vivado工程目录下的ad936x.runs/impl_1/system_top.bit，选中之后点击apply，Run之后等待下载完成就可以代码的烧录。\n本驱动提供一个测试案例来观测程序是否正常工作，AD9361是否正常收发数据。在PL产生一个正弦波与余弦波，将正弦波送入AD9361通道0的I路，余弦波送入AD9361通到0的Q路，通过连接到通道0的DAC的I路与Q路信号就可以将信号发射出去。将通道0的ADC的I路与Q路信号、通道0的DAC的的I路与Q路信号连接到ILA逻辑调试器上，下载完成之后，观测抓取到的波形，基带收发部分RTL代码如下：\nmodule tx_rx ( i_clk, i_rst_n, i_adc_data_i0, i_adc_data_q0, o_dac_data_i0, o_dac_data_q0 ); input i_clk; input i_rst_n; input [11:0] i_adc_data_i0; input [11:0] i_adc_data_q0; output [11:0] o_dac_data_i0; output [11:0] o_dac_data_q0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] i_adc_data_i0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] i_adc_data_q0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] o_dac_data_i0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] o_dac_data_q0; wire clk; wire rst_n; assign clk = i_clk; assign rst_n = i_rst_n; // 初始化完成之后，直接对dac_data_i0,dac_data_q0喂数据就可以达到发送的效果 // 直接对adc_data_i0，adc_data_q0读取就可以达到接收的效果 // 产生正弦波测试 sine_wave u_sine_wave ( .clk (clk), .dout_sin (o_dac_data_i0[11:4]), .dout_cos (o_dac_data_q0[11:4]) ); assign o_dac_data_i0[3:0] = 4\u0026#39;b0; assign o_dac_data_q0[3:0] = 4\u0026#39;b0; endmodule 点击open Hardware Manager连接芯片之后（如果连接失败检查一下是否工作在JTAG模式），点击运行触发按键，波形被抓取到并显示在波形框中，其中i_adc_data_i0与i_adc_data_q0为ADC采集到的射频信号，o_dac_data_i0与o_dac_data_q0为DAC发射的正弦波基带信号，如果ADC采集到的信号为标准的正弦波则芯片工作正常。\n如果连接芯片后没有出现ILA视图，则在Vivado重新烧录文件，烧录时添加上xxx.ltx文件，烧录后就可以显示出正常波形。\nIQ收发操作流程\r#\r对于大部分基带算法的时候，只需要关注DAC数据接口与ADC数据接口，本驱动暴露出了所有的DAC与ADC数据接口，包括两路ADC的I路与Q路信号，两路DAC的I路与Q路信号，以及ADC的有效信号，用户只需在随AD9361输出的数据时钟读写就可以完成信号的收发，AD9361接口图如下图：\n收发示例代码如下：\nmodule tx_rx ( i_clk, i_rst_n, i_adc_data_i0, i_adc_data_q0, o_dac_data_i0, o_dac_data_q0 ); input i_clk; input i_rst_n; input [11:0] i_adc_data_i0; input [11:0] i_adc_data_q0; output [11:0] o_dac_data_i0; output [11:0] o_dac_data_q0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] i_adc_data_i0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] i_adc_data_q0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] o_dac_data_i0; (*mark_debug = \u0026#34;true\u0026#34;*) wire [11:0] o_dac_data_q0; wire clk; wire rst_n; assign clk = i_clk; assign rst_n = i_rst_n; // DAC发射测试 // 初始化完成之后，直接对dac_data_i0,dac_data_q0喂数据就可以达到发送的效果 // 直接对adc_data_i0，adc_data_q0读取就可以达到接收的效果 // 产生正弦波测试 sine_wave u_sine_wave ( .clk (clk), .dout_sin (o_dac_data_i0[11:4]), .dout_cos (o_dac_data_q0[11:4]) ); reg [11:0] adc_data_i; reg [11:0] adc_data_q; // ADC接收测试 // 直接读取ADC数据接口的值 always @(posedge clk) begin adc_data_i \u0026lt;= i_adc_data_i0; adc_data_q \u0026lt;= i_adc_data_q0; end assign o_dac_data_i0[3:0] = 4\u0026#39;b0; assign o_dac_data_q0[3:0] = 4\u0026#39;b0; endmodule 其中AD9361输出时钟频率与PS的配置有关，默认状态下在1r1t的时钟频率为30.72MHz，在2r2t的时钟频率为61.44MHz。\n针对PS端对AD9361的配置，可以参考ADI No-Os官方的操作文档，链接为：\rAD9361 No-OS Software\n资源获取\r#\r知识付费，整套工程售价199元，购买方式：\nvx：RonyzBrown 咸鱼：\r购买链接 此外，本人可以承接FPGA、嵌入式软硬件设计、射频通信系统设计，欢迎沟通交流。\n"},{"id":2,"href":"/posts/note/git/git-note/","title":"Git Note","section":"Posts","content":"\r访问问题\r#\r连接不上\r#\rfatal: unable to access \u0026lsquo;\rhttps://github.com/xxx/.git/': Failed to connect to github.com port 443 after 21090 ms: Couldn\u0026rsquo;t connect to server\n开启VPN情况\r#\r一般出现这种问题都是开过VPN导致的本机系统端口号和git的端口号不一致导致的。\n解决办法：\n1.查看本机系统端口号\n设置-\u0026gt;网络和Internet-\u0026gt;代理\n2.设置git端口号和上面的端口号保持一致\ngit config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 设置完成可以查看是否配置成功：\n\u0026gt; git config --global -l user.email=xxx@xx.com user.name=xxx http.proxy=127.0.0.1:7890 https.proxy=127.0.0.1:7890 未开启VPN情况\r#\r还是一样的原因，两边端口不一致导致的，那么直接去掉git代理即可：\ngit config --global --unset http.proxy git config --global --unset https.proxy "}]